{"ast":null,"code":"import _toConsumableArray from \"@babel/runtime/helpers/toConsumableArray\";\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _extends from \"@babel/runtime/helpers/extends\";\nimport _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\nvar _jsxFileName = \"/Users/Morgan/Programmation/Pro/Hygo/hygoclient/src/components/v2/ModulationBar.js\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nimport React, { useState, Component, useEffect, useRef, useCallback, useMemo } from 'react';\nimport StyleSheet from \"react-native-web/dist/exports/StyleSheet\";\nimport View from \"react-native-web/dist/exports/View\";\nimport TouchableWithoutFeedback from \"react-native-web/dist/exports/TouchableWithoutFeedback\";\nimport PanResponder from \"react-native-web/dist/exports/PanResponder\";\nimport Dimensions from \"react-native-web/dist/exports/Dimensions\";\nimport COLORS from \"../../colors\";\nimport _ from 'lodash';\nimport { CONDITIONS } from \"../../constants\";\nvar NUM_ITEMS = 24;\nvar CURSOR_HEIGHT = 120;\nvar conditionsOrdering = ['FORBIDDEN', 'BAD', 'CORRECT', 'GOOD', 'EXCELLENT'];\n\nvar ModulationBar = function ModulationBar(_ref) {\n  var from = _ref.from,\n      initialMin = _ref.initialMin,\n      initialMax = _ref.initialMax,\n      data = _ref.data,\n      width = _ref.width,\n      onHourChangeEnd = _ref.onHourChangeEnd;\n\n  var _useState = useState({\n    min: parseInt(initialMin ? initialMin : 0),\n    max: parseInt(initialMax ? initialMax : 0)\n  }),\n      _useState2 = _slicedToArray(_useState, 2),\n      selected = _useState2[0],\n      setSelected = _useState2[1];\n\n  var selectedRef = useRef(selected);\n  selectedRef.current = selected;\n  var panResponder = useMemo(function () {\n    return PanResponder.create({\n      onMoveShouldSetPanResponderCapture: function onMoveShouldSetPanResponderCapture() {\n        return true;\n      },\n      onStartShouldSetPanResponder: function onStartShouldSetPanResponder() {\n        return true;\n      },\n      onPanResponderStart: function onPanResponderStart(evt, gestureState) {\n        return onStart(evt, gestureState);\n      },\n      onPanResponderMove: function onPanResponderMove(evt, gestureState) {\n        return onMove(evt, gestureState);\n      },\n      onPanResponderRelease: function onPanResponderRelease() {\n        if (onHourChangeEnd) {\n          onHourChangeEnd(selectedRef.current);\n        }\n      }\n    });\n  }, []);\n\n  var onStart = function onStart(evt, gestureState) {\n    var xpos = gestureState.x0 + gestureState.dx;\n    var offset = (Dimensions.get('window').width - width) / 2;\n    var fv = (xpos - offset) / width * NUM_ITEMS;\n    var posInsideBar = parseInt(fv);\n\n    if (posInsideBar > NUM_ITEMS - 1) {\n      posInsideBar = NUM_ITEMS - 1;\n    }\n\n    if (posInsideBar < 0) {\n      posInsideBar = 0;\n    }\n\n    setSelected(function (_ref2) {\n      var min = _ref2.min,\n          max = _ref2.max;\n      return posInsideBar > max + 1 || posInsideBar < min - 1 ? {\n        min: posInsideBar,\n        max: posInsideBar\n      } : {\n        min: min,\n        max: max\n      };\n    });\n  };\n\n  var onMove = function onMove(evt, gestureState) {\n    var xpos = gestureState.x0 + gestureState.dx;\n    var offset = (Dimensions.get('window').width - width) / 2;\n    var fv = (xpos - offset) / width * NUM_ITEMS;\n    var dv = fv % 1;\n\n    if (gestureState.vx > 0) {\n      if (dv >= 0.65) {\n        fv = parseInt(fv) + 1;\n      } else {\n        fv = parseInt(fv);\n      }\n    } else if (gestureState.vx < 0) {\n      if (dv <= 0.35) {\n        fv = parseInt(fv);\n      } else {\n        fv = parseInt(fv) + 1;\n      }\n    }\n\n    var posInsideBar = fv;\n\n    if (posInsideBar > NUM_ITEMS - 1) {\n      posInsideBar = NUM_ITEMS - 1;\n    }\n\n    if (posInsideBar < 0) {\n      posInsideBar = 0;\n    }\n\n    setSelected(function (selected) {\n      var min = selected.min,\n          max = selected.max;\n\n      if (gestureState.vx > 0) {\n        if (posInsideBar === max + 1) {\n          max = posInsideBar;\n        } else if (posInsideBar === min && max !== posInsideBar) {\n          min = posInsideBar + 1;\n        }\n      } else {\n        if (posInsideBar === min - 1) {\n          min = posInsideBar;\n        } else if (posInsideBar === max && posInsideBar !== min) {\n          max = posInsideBar - 1;\n        }\n      }\n\n      return max - min < 12 ? {\n        min: min,\n        max: max\n      } : selected;\n    });\n  };\n\n  var getColor = function getColor(i) {\n    var isSelected = i <= selected.max && selected.min <= i;\n    if (isSelected) return 'transparent';\n    var color_name = CONDITIONS[data[i + from]] + \"_CARDS\";\n    return COLORS[color_name];\n  };\n\n  var getItemWidth = function getItemWidth(i, isSub) {\n    var w = width;\n    var margin = parseFloat(w) / NUM_ITEMS * 0.14;\n    var isSelected = i <= selected.max && selected.min <= i;\n    return {\n      width: parseFloat(w) / NUM_ITEMS,\n      paddingHorizontal: isSelected ? 0 : margin,\n      paddingVertical: 5,\n      height: 55 + (isSelected ? margin : 0)\n    };\n  };\n\n  var getSelectedWidth = function getSelectedWidth() {\n    if (selected.max < selected.min) {\n      return {\n        width: 0,\n        boderWidth: 0\n      };\n    }\n\n    var curCond = null;\n\n    for (var i = selected.min; i <= selected.max; i++) {\n      if (!curCond || CONDITIONS.indexOf(curCond) >= data[i + from]) {\n        curCond = CONDITIONS[data[i + from]];\n      }\n    }\n\n    var w = width,\n        margin = parseFloat(w) / NUM_ITEMS * 0.14;\n    return {\n      width: (selected.max - selected.min + 1) * (parseFloat(w) / NUM_ITEMS),\n      marginHorizontal: 0,\n      borderWidth: margin,\n      borderColor: '#fff',\n      height: 45 + margin,\n      position: 'absolute',\n      left: selected.min * width / NUM_ITEMS,\n      backgroundColor: COLORS[curCond + \"_CARDS\"]\n    };\n  };\n\n  var getContainerHeight = function getContainerHeight() {\n    var w = width,\n        margin = parseFloat(w) / NUM_ITEMS * 0.14;\n    return 45 + margin;\n  };\n\n  return React.createElement(View, {\n    style: [styles.container, {\n      width: width,\n      height: getContainerHeight()\n    }],\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 180,\n      columnNumber: 9\n    }\n  }, React.createElement(View, _extends({\n    style: [styles.parcelleCursor, {\n      left: -1 * parseFloat(Dimensions.get('window').width - width) / 2,\n      width: Dimensions.get('window').width,\n      height: CURSOR_HEIGHT\n    }]\n  }, panResponder.panHandlers, {\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 181,\n      columnNumber: 13\n    }\n  })), React.createElement(View, {\n    style: [styles.selected, _objectSpread({}, getSelectedWidth())],\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 189,\n      columnNumber: 13\n    }\n  }), _toConsumableArray(Array(NUM_ITEMS).keys()).map(function (i) {\n    return React.createElement(TouchableWithoutFeedback, {\n      key: i,\n      onPress: function onPress() {},\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 194,\n        columnNumber: 21\n      }\n    }, React.createElement(View, {\n      style: [styles.parcelle, _objectSpread({}, getItemWidth(i))],\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 195,\n        columnNumber: 25\n      }\n    }, React.createElement(View, {\n      style: [styles.subTile, {\n        backgroundColor: getColor(i)\n      }],\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 199,\n        columnNumber: 29\n      }\n    })));\n  }));\n};\n\nvar styles = StyleSheet.create({\n  container: {\n    display: 'flex',\n    flexDirection: 'row',\n    paddingVertical: 5,\n    justifyContent: 'center',\n    alignItems: 'center'\n  },\n  parcelleCursor: {\n    position: 'absolute',\n    backgroundColor: 'transparent',\n    zIndex: 10\n  },\n  parcelle: {\n    height: 45,\n    zIndex: 5\n  },\n  subTile: {\n    height: 45,\n    zIndex: 5\n  },\n  selected: {\n    height: 45,\n    zIndex: 1\n  }\n});\nexport default ModulationBar;","map":{"version":3,"sources":["/Users/Morgan/Programmation/Pro/Hygo/hygoclient/src/components/v2/ModulationBar.js"],"names":["React","useState","Component","useEffect","useRef","useCallback","useMemo","COLORS","_","CONDITIONS","NUM_ITEMS","CURSOR_HEIGHT","conditionsOrdering","ModulationBar","from","initialMin","initialMax","data","width","onHourChangeEnd","min","parseInt","max","selected","setSelected","selectedRef","current","panResponder","PanResponder","create","onMoveShouldSetPanResponderCapture","onStartShouldSetPanResponder","onPanResponderStart","evt","gestureState","onStart","onPanResponderMove","onMove","onPanResponderRelease","xpos","x0","dx","offset","Dimensions","get","fv","posInsideBar","dv","vx","getColor","i","isSelected","color_name","getItemWidth","isSub","w","margin","parseFloat","paddingHorizontal","paddingVertical","height","getSelectedWidth","boderWidth","curCond","indexOf","marginHorizontal","borderWidth","borderColor","position","left","backgroundColor","getContainerHeight","styles","container","parcelleCursor","panHandlers","Array","keys","map","parcelle","subTile","StyleSheet","display","flexDirection","justifyContent","alignItems","zIndex"],"mappings":"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","sourcesContent":["import React, { useState, Component, useEffect, useRef, useCallback, useMemo } from 'react'\nimport { StyleSheet, View, TouchableWithoutFeedback, PanResponder, Dimensions } from 'react-native'\n\nimport COLORS from '../../colors'\nimport _ from 'lodash';\nimport { CONDITIONS } from '../../constants';\n\nconst NUM_ITEMS = 24\nconst CURSOR_HEIGHT = 120\n\nconst conditionsOrdering = ['FORBIDDEN', 'BAD', 'CORRECT', 'GOOD', 'EXCELLENT']\n\n// previously named HygoParcelleIntervention\n\nconst ModulationBar = ({ from, initialMin, initialMax, data, width, onHourChangeEnd }) => {\n    /**\n     * \n     * @param props\n     * { from, initialMin, initialMax, data ,width, onHourChangeEnd}\n     * \n     * Main idea : using a panResponder to handle dragging\n     * the selected slots are made transparent, and there is a rectangle behind \n     * that do the color of the selected slot\n     */\n\n\n    const [selected, setSelected] = useState({\n        min: parseInt(initialMin ? initialMin : 0),\n        max: parseInt(initialMax ? initialMax : 0)\n    })\n    //useRef needed for onPanResponderRelease\n    const selectedRef = useRef(selected)\n    selectedRef.current = selected\n\n    const panResponder = useMemo(() => PanResponder.create({\n        onMoveShouldSetPanResponderCapture: () => true,\n        onStartShouldSetPanResponder: () => true,\n        onPanResponderStart: (evt, gestureState) => onStart(evt, gestureState),\n        onPanResponderMove: (evt, gestureState) => onMove(evt, gestureState),\n        onPanResponderRelease: () => {\n            //selected is not changing here because we use useMemo()\n            if (onHourChangeEnd) {\n                onHourChangeEnd(selectedRef.current)\n            }\n        }\n    }), [])\n\n    const onStart = (evt, gestureState) => {\n        /**\n        * Handle the gesture when touching the finger\n        */\n        const xpos = gestureState.x0 + gestureState.dx\n        const offset = (Dimensions.get('window').width - width) / 2\n        let fv = (xpos - offset) / width * NUM_ITEMS\n\n        // slot number where we are\n        let posInsideBar = parseInt(fv)\n        // out of bounds ?\n        if (posInsideBar > NUM_ITEMS - 1) { posInsideBar = NUM_ITEMS - 1 }\n        if (posInsideBar < 0) { posInsideBar = 0 }\n\n        // be careful with the problem of stale closure with react Hooks\n        \n        setSelected(({min, max}) => {\n            // if we touch outside of the selection : update selection\n            return (posInsideBar > max + 1) || (posInsideBar < min - 1) ? ({\n                min: posInsideBar,\n                max: posInsideBar\n            }) : ({min, max})  \n        })\n    }\n\n    const onMove = (evt, gestureState) => {\n        /**\n         * Handle the gesture when moving the finger\n         */\n        const xpos = gestureState.x0 + gestureState.dx\n        const offset = (Dimensions.get('window').width - width) / 2\n        let fv = (xpos - offset) / width * NUM_ITEMS\n        // dv: where we are inside the slot : 0(top left) -> 1(top right)\n        const dv = fv % 1\n\n        if (gestureState.vx > 0) {\n            if (dv >= 0.65) { fv = parseInt(fv) + 1 }\n            else { fv = parseInt(fv) }\n        } else if (gestureState.vx < 0) {\n            if (dv <= 0.35) { fv = parseInt(fv) }\n            else { fv = parseInt(fv) + 1 }\n        }\n\n        // slot number where we are\n        let posInsideBar = fv\n        // if we are out of bound : reframe\n        if (posInsideBar > NUM_ITEMS - 1) { posInsideBar = NUM_ITEMS - 1 }\n        if (posInsideBar < 0) { posInsideBar = 0 }\n\n        // be careful with the problem of stale closure with react Hooks\n        setSelected((selected) => {\n            let {min, max} = selected\n            if (gestureState.vx > 0) {\n                if (posInsideBar === max + 1) {\n                    max = posInsideBar\n                } else if (posInsideBar === min && max !== posInsideBar) {\n                    min = posInsideBar + 1\n                }\n            } else {\n                if (posInsideBar === min - 1) {\n                    min = posInsideBar\n                } else if (posInsideBar === max && posInsideBar !== min) {\n                    max = posInsideBar - 1\n                }\n            }\n            return ((max - min) < 12) ? ({min, max}) : (selected)\n        })\n    }\n\n    const getColor = (i) => {\n        // if selected : color is transparent\n        // else the color is taken from the data provided\n        const isSelected = i <= selected.max && selected.min <= i\n        if (isSelected)\n            return 'transparent'\n        const color_name = `${CONDITIONS[data[i + from]]}_CARDS`\n        return COLORS[color_name];\n    }\n\n    const getItemWidth = (i, isSub) => {\n\n        const w = width\n        const margin = parseFloat(w) / NUM_ITEMS * 0.14\n        const isSelected = i <= selected.max && selected.min <= i\n        return {\n            width: parseFloat(w) / NUM_ITEMS,\n            paddingHorizontal: isSelected ? 0 : margin,\n            paddingVertical: 5,\n            height: 55 + (isSelected ? margin : 0),\n        }\n    }\n\n    const getSelectedWidth = () => {\n        /**\n         * Get the width of the rectagle in the background that will do the color\n         *  for the selected slot\n         *  The color is the worst color of all the selected slots\n         */\n        if (selected.max < selected.min) {\n            return {\n                width: 0,\n                boderWidth: 0,\n            }\n        }\n\n        let curCond = null\n        for (let i = selected.min; i <= selected.max; i++) {\n            // find worst condition over the selected slot\n            if (!curCond || CONDITIONS.indexOf(curCond) >= data[i + from]) {\n                curCond = CONDITIONS[data[i + from]]\n            }\n        }\n\n        const w = width, margin = parseFloat(w) / NUM_ITEMS * 0.14\n        return {\n            width: (selected.max - selected.min + 1) * (parseFloat(w) / NUM_ITEMS),\n            marginHorizontal: 0,\n            borderWidth: margin,\n            borderColor: '#fff',\n            height: 45 + margin,\n            position: 'absolute',\n            left: selected.min * width / NUM_ITEMS,\n            backgroundColor: COLORS[`${curCond}_CARDS`],\n        }\n    }\n\n    const getContainerHeight = () => {\n        const w = width, margin = parseFloat(w) / NUM_ITEMS * 0.14\n        return 45 + margin\n    }\n\n    return (\n        <View style={[styles.container, { width: width, height: getContainerHeight() }]}>\n            <View style={[styles.parcelleCursor, {\n                left: -1 * parseFloat(Dimensions.get('window').width - width) / 2,\n                width: Dimensions.get('window').width,\n                height: CURSOR_HEIGHT,\n            }]}\n                {...panResponder.panHandlers}></View>\n\n            {/* The background rectangle*/}\n            <View style={[styles.selected, { ...getSelectedWidth() }]}></View>\n\n            {/* The slots */}\n            {[...Array(NUM_ITEMS).keys()].map(i => {\n                return (\n                    <TouchableWithoutFeedback key={i} onPress={() => { }}>\n                        <View style={[styles.parcelle, {\n                            ...getItemWidth(i)\n                        },\n                        ]}>\n                            <View style={[styles.subTile, { backgroundColor: getColor(i), }]}></View>\n                        </View>\n                    </TouchableWithoutFeedback>\n                )\n            })}\n        </View>\n    )\n}\n\nconst styles = StyleSheet.create({\n    container: {\n        display: 'flex',\n        flexDirection: 'row',\n        paddingVertical: 5,\n        justifyContent: 'center',\n        alignItems: 'center',\n    },\n    parcelleCursor: {\n        position: 'absolute',\n        backgroundColor: 'transparent',\n        zIndex: 10,\n    },\n    parcelle: {\n        height: 45,\n        zIndex: 5,\n    },\n    subTile: {\n        height: 45,\n        zIndex: 5\n    },\n    selected: {\n        height: 45,\n        zIndex: 1,\n    }\n})\n\nexport default ModulationBar"]},"metadata":{},"sourceType":"module"}